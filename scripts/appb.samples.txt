Example 1:

#set our macros
ext_if="fxp1"           #the external interface
int_if="fxp0"           #the internal interface
internal_net="192.168.1.0/24"

#first, normalize packets we transmit and receive
scrub in all

#then, give NAT to our internal addresses
nat on $ext_if from $internal_net to any -> ($ext_if)

#We want outbound FTP to work properly, so let's enable the
#FTP proxy.  Be sure you have ftp-proxy running out of inetd(8)!
rdr on $int_if proto tcp from any to any port ftp -> 127.0.0.1 port 8021

#We're not doing any packet shaping, so let's go directly to the
#packet filtering.  We'll block everything first, and then only
#explicitly allow desirable traffic.

block in log all

#As our client operating systems may be running some godforsaken
#operating system with poor ISN selection, we'll use state modulation.

pass in on $int_if inet from $internal_net to any modulate state

#I'd like to be able to SSH to my network from anywhere
pass in on $ext_if inet proto tcp from any to ($ext_if) port ssh keep state

#and, don't forget to allow our ftp-proxy program to connect back to
#the firewall!
pass in on $ext_if inet proto tcp from any to ($ext_if) user proxy keep state

Example 2:

#set our macros
ext_if="fxp1"
int_if="fxp0"

ext_ip="209.69.178.18"
int_ip="192.168.1.1"
ext_net="209.69.178.16/28"
int_net="192.168.1.0/24"

#use macros for our web servers and mail server
webserver="192.168.1.2"
mailserver="192.168.1.3"

#first, normalize packets we transmit and receive
scrub in all

#now, set up our traffic queues
#
# the parent queue:
altq on $ext_if cbq bandwidth 100Mb queue {local, t1}

#the child queue for communication to our local network outside the
#firewall.  This queue can borrow traffic from the T1, if the T1 isn't
#full.
queue local bandwidth 98456Kb cbq(borrow)

#the child queue for T1 traffic.  This queue cannot borrow traffic
#from the parent; once the T1 is full, it's full!
queue t1 bandwidth 1544Kb {ssh, http-in, http-out, mail, dns, ftp, misc}

#now the child queues for our T1 circuit, shaping our usage the way we want.
queue http-in bandwidth 25% cbq(borrow)
queue http-out bandwidth 25% cbq(borrow, red)
queue mail bandwidth 25% cbq(borrow)
queue dns bandwidth 4% cbq(borrow)
queue ftp bandwidth 20% cbq(borrow, red)
queue misc bandwidth 1% cbq(borrow, default)

#give NAT to our internal addresses
nat on $ext_if from $int_net to any -> ($ext_if)

#We want outbound FTP to work properly, so let's enable the 
#FTP proxy.  Be sure you have ftp-proxy running out of inetd(8)!
rdr on $int_if proto tcp from any to any port ftp -> 127.0.0.1 port 8021

#Redirect requests to our external IP address to the proper internal IP
rdr on $ext_if proto tcp from any to $ext_ip port www -> $webserver port www
rdr on $ext_if proto tcp from any to $ext_ip port smtp -> $mailserver port smtp

#Block everything first, and then explicitly allow only desirable
#traffic.
block in log all

#We have incoming connections to our mail and web server.
#Be sure to use the translated IP addresses here!
#Using macros will ensure that you have the correct IP.

pass in on $ext_if proto tcp from any to $webserver port www keep state queue http-in
pass in on $ext_if proto tcp from any to $mailserver port smtp keep state queue mail

#Allow our ftp-proxy program to connect back to the firewall! 
pass in on $ext_if inet proto tcp from any to $ext_ip user proxy keep state

#The next rules cover traffic from inside the network, going out As
#our client operating systems may be running some godforsaken
#operating system with poor ISN selection, we'll use state modulation.
#Remember, the last matching rule is attached to the packet

#first, we set up the misc queue, where traffic will go if nothing
#else fits better.  People can use P2P programs if nothing more
#important is running.

pass out on $ext_if from $int_net to any queue misc

#pass out on $ext_if from $int_net proto tcp to any port { www, https } modulate state queue http-out
#pass out on $ext_if from $int_net proto { tcp, udp } to any port domain modulate state queue dns
#pass out on $ext_if from $int_net proto tcp to any port { ftp, ftp-data } modulate state queue ftp
#pass out on $ext_if from $mailserver proto tcp to any port smtp modulate state queue mail

#lastly, catch all traffic bound for the local exterior network and
#drop it in the big queue; basically unlimited bandwidth on the local
#ethernet, after all!

pass out on $ext_if from $int_net to $ext_net modulate state queue local

#protect against spoofing
antispoof for $int_if
antispoof for $ext_if


Example 3:

# Application Tier Firewall Configuration
#set our macros

ext_if = "fxp1"
int_if = "fxp0"
ext_ip = "209.69.178.26"
int_ip = "192.168.1.1"
ext_net = "209.69.178.16/28"
int_net = "192.168.1.0/24"
db_net = "172.168.0.0/24"
mgmt_net = "209.69.178.18/32"

#also use macros for our load-balanced application servers

appservers = "{ 192.168.1.4, 192.168.1.5, 192.168.1.6, 192.168.1.7 }"

#normalize all traffic we receive and transmit
scrub in all

#use NAT so we can access internal equipment, such as switches, from
#the outside world.
nat on $ext_if from { $db_net, $int_net } to any -> $ext_ip

#here, we load-balance our application servers
rdr on fxp1 proto tcp from any to $ext_ip port { 80, 443 } -> $appservers

#
block in log all

#allow traffic from the world to our application server
pass in on $ext_if proto tcp from any to $appservers port { 80, 443 } keep state

#allow packets from our management network (a single IP, in this case) to 
#enter the network

pass in on $ext_if proto tcp from $mgmt_net to { $db_net, $int_net } keep state

#lastly, make sure we are spoof-protected
antispoof for $ext_if
antispoof for $int_if

# Database Tier Firewall Configuration

#set our macros

ext_if = "fxp1"
int_if = "fxp0"
ext_ip = "192.168.1.254"
int_ip = "172.16.0.1"
ext_net = "192.168.1.0/24"
int_net = "172.16.0.0/24"
mgmt_net = "209.69.178.18/32"

#our database server

dbserver = "172.16.0.2"

#normalize all traffic we receive and transmit
scrub in all

#Our application tier firewall is doing NAT for us, so we do not need
#to NAT further...

#...but we do need to filter traffic
block in log all

#allow traffic from the world to our application server
#Port 1723 is used by the Oracle listener; each database has its own port~
pass in on $ext_if proto tcp from $ext_net to $dbserver port 1521 keep state

#allow packets from our management network (a single IP, in this case) to
#enter the network
pass in on $ext_if proto tcp from $mgmt_net to $db_net, $int_net keep state

#lastly, make sure we are spoof-protected
antispoof for $ext_if
antispoof for $int_if
